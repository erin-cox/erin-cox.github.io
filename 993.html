---
title: EWD993 &ndash; The nature of my research and why I do it
layout: default
category: ewd
---

<sig>Edsger W. Dijkstra</sig>
<p>(Luncheon speech for Las Cruces, 14 November 1986.)</p>
<p>In 1955, as a young and promising theoretical physicist, I decided to devote my scientific life to programming instead, because I felt that programming well presented the greater intellectual challenge.</p>
<p>The next decade was devoted to gathering experience by designing and implementing systems of increasing size, ambition, and sophistication. By 1965 I could forcefully argue that the ability of detecting in an early stage the need for some special-purpose theory was one of the programmer&#8217;s most important assets.</p>
<p>Another five years later I formulated the core of the programming challenge as how to prevent the generation of unmanageable complexity. It became clear&mdash;to me at least&mdash;that the challenge was a mathematical one. By 1975 I had developed a formal system in which the program and its correctness proof could be designed hand in hand.</p>
<p>I was very excited because that was really great: another area of human endeavour had been shown to be in principle amenable to mathematical treatment.</p>
<p>From a purely technical point of view it is in retrospect amazing that it took me no less than two decades to reach that stage. From a sociological point of view, this slowness is easy to understand: the conclusion was almost universally unpopular. Programmers, and even more so their industrial managers, decried the whole idea as too academic to be of any practical significance. (Many of them still do.) The mathematicians ignored or denied the conclusion, because the type of mathematics needed was so different from what they were used to that they hardly recognized it as mathematics. (Many of them still don&#8217;t.) At the time I did not understand the vigour of the academic opposition, but it quickly convinced me that computing science had to develop itself the type of mathematics it needed. In retrospect I can understand the rejection: the stress must have seemed all wrong. In a nutshell: whereas during the last century mathematics as intellectual disciplin has become more and more knowledge-oriented, most of that knowledge was totally irrelevant for us; for us, for instance, the choice of notation seemed much more often to be the crucial decision.</p>
<p>So I found myself analyzing which habits and which precautions should be cultivated for the mathematical answer to the programming challenge. In the beginning I booked those explorations under the to me familiar heading of &ldquo;programming methodology&rdquo;.</p>
<p>But then all sorts of things started happening. By virtue of its mechanical interpretability, a programming language inveitably represents a formal system of some sort, and hence program derivation is unavoidably a highly formal activity. But this activity is only doable provided we find ways of preventing the amount of formal labour needed from exploding. As soon as brevity becomes a conscious goal, one begins to ask oneself &ldquo;What makes formal derivations lengthy?&rdquo; Not surprisingly, case analysis emerges as a main culprit. So one asks oneself &ldquo;What techniques do we have for avoiding case analysis?&rdquo;. And one finds a few, some of them sometimes even very effective. (Later in this talk, as time permits, I shall mention some of them.)</p>
<p>Shortly thereafter, the reading of a well-known, generally recommended and widely used mathematical textbook leaves one completely aghast! The arguments&mdash;and even the formulations of the theorems&mdash;are often so incredibly clumsy that one is forced to conclude that one&#8217;s explorations have a bearing on mathematics in general.</p>
<p><em>Example.</em> In &ldquo;An Introduction to Number Theory&rdquo; by Harold M. Stark, a main theorem is formulated as follows:</p>
<blockquote>
    If \(n\) is an integer greater than 1, then either \(n\) is prime or \(n\) is a finite product of primes.
</blockquote>
<p>But 1 is certainly finite, and by defining the product of 1 factor&mdash;how else?&mdash;to be equal to that factor we can do away with the case distinction in the consequent:</p>
<blockquote>
    If \(n\) is an integer greater than 1, then \(n\) is a finite product of primes.
</blockquote>
<p>But also 0 is certainly finite and by defining the product of 0 factors&mdash;how else?&mdash;to be equal to 1 we can do away with the exception:</p>
<blockquote>
    If \(n\) is a positive integer, then \(n\) is a finite product of primes.
</blockquote>
<p>Finally we can do away with the identifier \(n\):</p>
<blockquote>
    A positive integer is a finite product of primes.
</blockquote>
<p>(End of Example.)</p>
<p>In connection with the above example I would like to stress that a clumsy formulation of a theorem is a prototype of an unfortunate interface in the sense that it tends to increase labour on both sides of the fence: it makes the theorem harder to prove and harder to use.</p>
<p>Thus I found myself drawn into a wider topic than just &ldquo;programming methodology&rdquo;. Sometimes I call it&mdash;mainly for private purposes&mdash;&ldquo;the streamlining of the mathematical argument&rdquo;, a name partly chosen to express that we were exploring to what extent the experience gained from programming methodology could be carried over to mathematics in general, and partly chosen because it reflected a shift in emphasis, viz. from polishing existing arguments to the discipline of designing in an orderly fashion new arguments. As time went by, heuristics entered the picture.</p>
<p>In these activities we found a new appreciation for formalisms as an alternative to verbal thinking. We learned that formalisms are much more than a shorthand: we now consider them as the main means for freeing ourselves from the shackles of our native tongues.</p>
<p>Let me give you two examples of how confusing our languages are. By the Law of the Counterpositive, \(A\implies B\) is the same as \(\lnot B \implies \lnot A\). The implication is linguistically rendered by prefixing the antecedent with &ldquo;if&rdquo;, e.g.</p>
<blockquote>It will rain tomorrow if the wind does not turn</blockquote>
<p>a perfectly acceptable sentence. The counterpositive, however, yields:</p>
<blockquote>The wind turns if it won&#8217;t rain tomorrow</blockquote>
<p>a funny statement, to say the least. Evidently, the conjunctive &ldquo;if&rdquo; carries with it a whole extra-logical burden of before/after or of cause/effect (a dichotomy for which there is no place in the inanimate world). Verbal mathematics has learned to strip the conjunctive &ldquo;if&rdquo; from that extra-logical burden, but only to a certain extent, as is shown by the following example. Logical equivalence, alias the mutual implication, is verbally rendered by &ldquo;if and only if&rdquo;, as in</p>
<blockquote>An integer \(n\) is even if and only if \(n+1\) is odd.</blockquote>
<p>So far so good, but have now a look at the following sentence:</p>
<blockquote>I see with both eyes if and only if I see with one eye if and only if I am blind.</blockquote>
<p>Linguistically, this is complete gibberish because the sentence can be parsed in two different ways. Its blatant syntactical ambiguity prevents it from being an acceptable sentence. Logically, it is of the form \(A\equiv B \equiv C\) and we are, indeed, free to omit the parentheses since the boolean operator of equivalence is associative: the continued equivalence means that the number of false operands is even, and since I do not have more than 2 eyes, the above statement, though baffling gibberish, is formally correct.</p>
<p>In mathematical reasoning, the equivalence is a grossly underexploited relation, and there is no doubt in my mind that this is closely related to the linguistic shortcomings of the verbal rendering &ldquo;if and only if&rdquo;. Consequently, I have come to the conclusion that it is a mistake to teach logic by translating formulae into prose, for that is precisely the vehicle from which we want to increase our distance. My characterization &ldquo;grossly underexploited&rdquo; is no exaggeration: the judicious use of the equivalence has reduced many an existing argument by an order of magnitude. (I have seen reduction factors of 16 and 24.) The explanation is probably to be found in the nice properties of the equivalence, such as symmetry, associativity and the fact that disjunction distributes over it; moreover it has the full power of equality, i.e. \(x = y \implies f\,.x = f\,.y\).</p>
<p>Formalization, in general the reduction of a greater part of mathematics to calculation, is not our goal. It just happened, and in this connection I would like to stress that our experience is directly opposite to what is commonly held as unshakable dogma, viz. that formal treatments are always long, tedious, laborious, error-prone and what not. On the contrary, a more calculational treatment has invariably led to a crisper argument. My conclusion is that the bad name of formal techniques is undeserved. Our experience is so striking and, at the same time so contrary to what is generally felt that you may have difficulty believing me. So let me venture an explanation why so many people have such poor experiences with formal mathematics.</p>
<ol class="paragraph-spaced-list" style="list-style-type: lower-roman;">
    <li>Many established notation conventions are not well geared to our manipulative needs, e.g. by being ambiguous or by denying us the combinatorial freedom we need.</li>
    <li>Some calculation styles introduce many steps that are better avoided. When using an associative operator, one may confine oneself to fully parenthesized expressions, explicitly shuffling, when needed, the parentheses by an appeal to
    \[
    (X\cdot Y)\cdot Z = X\cdot (Y \cdot Z)\text{.}
    \]
    Just dropping the superfluous parentheses is much simpler.
    </li>
    <li>Many people have failed to develop a sufficiently reliable handwriting: they think that formal mathematics is hard while in actual fact they only lack some simple hand-eye coordination.</li>
</ol>
<p>It was the dream of Leibniz to reduce all of mathematical reasoning to a universally applicable calculus. Not being Leibniz, we are more modest: we won&#8217;t hesitate to calculate when it comes in handy.</p>
<p>But Leibniz needs to be mentioned in connection with computing science because it could very well be that that discipline gets the task of realizing most of his dream. The reasons are the following:</p>
<ul>
    <li>The kind of complexity that computing scientists face makes formal techniques indispensable.</li>
    <li>From his experience, the computing scientist is intimately familiar with the idea of manipulating uninterpreted formulae.</li>
    <li>If the need arises, the computing scientist has the technology for mechanization at his disposal.</li>
</ul>
<p>If ours is the task of realizing the dream of Leibniz, let us see to it that it does not turn into a nightmare!</p>
<div class="address">
    <address style="margin-top: 1.8em;">
    prof. dr. Edsger W. Dijkstra<br>
    Department of Computer Sciences<br>
    The University of Texas at Austin<br>
    Austin, TX 78712-1188, USA
    </address>
</div>