---
title: A proposal for English spelling reform
layout: default
category: language
---

<table style="width: 50%">
  <colgroup>
    <col style="width: 40%;"/>
    <col style="width: 20%;"/>
    <col style="width: 40%;"/>
  </colgroup>
  <tr><td>rough</td><td>&#8594;</td><td>ruf</td></tr>
  <tr><td>fair</td><td>&#8594;</td><td>fé</td></tr>
  <tr><td>cheese</td><td>&#8594;</td><td>ćíz</td></tr>
  <tr><td>honest</td><td>&#8594;</td><td>onist</td></tr>
  <tr><td>connoisseur</td><td>&#8594;</td><td>conysý</td></tr>
</table>

<h2>In short</h2>

A one-to-one mapping between English phonemes and letters, much like Jan Hus&#8217; reform of Czech orthography described in <em><a href="https://en.wikipedia.org/wiki/Orthographia_bohemica" target="_blank" rel="noreferrer">De orthographia bohemica</a></em>. The {{ site.data.spelling.letters | where: "is_vowel", false | size }} consonants and {{ site.data.spelling.letters | where: "is_vowel", true | size }} vowels of the alphabet are given below, along with the {{ site.data.spelling.diphthongs | size }} double vowels:

<style>
.alphabet div {
    background-color: #f0f0f0;
    border-radius: 5px;
    margin: 0px -1px;
}

.alphabet div:hover {
    cursor: pointer;
}
</style>

<script>
var DIACRITIC_LETTERS = {{- site.data.spelling.letters | jsonify -}};
DIACRITIC_LETTERS = Object.keys(DIACRITIC_LETTERS)
    .reduce((acc, letter) => {
        const mod = DIACRITIC_LETTERS[letter]["modification_of"];
        if (mod !== null && mod !== undefined) {
            acc[mod] = letter;
        }
        return acc;
    }, {});


const equalCaseInsensitive = (a,b) =>
    a.localeCompare(b, "en", { sensitivity: "accent"}) === 0;
const isUpper = (c) => c === c.toUpperCase();
const isLower = (c) => !isUpper(c);

const addDiacritics = () => {
    const text_area = document.getElementById("input");
    const contents = text_area.value;
    const cursor_pos = text_area.selectionEnd;
    console.log(contents, cursor_pos);
    if (cursor_pos > 0 && equalCaseInsensitive(contents[cursor_pos-1], "{{ site.data.spelling.accent_key }}")) {
        var cased_letter;
        if (cursor_pos > 1) {
            const unmodified_letter = contents[cursor_pos-2];
            const letter = DIACRITIC_LETTERS[unmodified_letter.toLowerCase()];
            cased_letter = letter === undefined ? "" :
                isUpper(unmodified_letter) ? letter.toUpperCase() : letter;
        }
        else {
            cased_letter = "";
        }
        const start_up_to = cased_letter === ""
            ? cursor_pos - 1
            : cursor_pos - 2;
        const start = contents.slice(0, start_up_to);
        const end = contents.slice(cursor_pos);
        const new_contents = `${start}${cased_letter}${end}`;
        text_area.value = new_contents;
        text_area.selectionEnd = cursor_pos - 1;
    }
}
</script>

<table class="alphabet" style="width: 60%;">
  <colgroup>
    {%- assign length = site.data.spelling.letters_per_row -%}
    {%- assign width = 100 | divided_by: length -%}
    {%- for i in (1..site.data.spelling.letters_per_row) -%}
    <col style="width: {{ width }}%;"/> <!-- generate the width % -->
    {%- endfor -%}
  </colgroup>
  {% for letter_data in site.data.spelling.letters -%}
    {%- assign rem = forloop.index0 | modulo: site.data.spelling.letters_per_row %}
    {%- if rem == 0 %}<tr>{% endif -%}
    <td><div onmouseover="update_letter_display('{{ letter_data[0] }}')">{{ letter_data[0] | upcase }}{{ letter_data[0] }}</div></td>
    {%- assign i_1 = site.data.spelling.letters_per_row | minus: 1 -%}
    {%- if rem == i_1 %}</tr>{% endif -%}
  {% endfor %}
  <tr style="height: 0.4em;"></tr>
  {% for diphthong_data in site.data.spelling.diphthongs -%}
    {%- assign rem = forloop.index0 | modulo: site.data.spelling.letters_per_row %}
    {%- if rem == 0 %}<tr>{% endif -%}
    <td><div onmouseover="update_letter_display('{{ diphthong_data[0] }}')">{{ diphthong_data[0] }}</div></td>
    {%- assign i_1 = site.data.spelling.letters_per_row | minus: 1 -%}
    {%- if rem == i_1 %}</tr>{% endif -%}
  {% endfor %}
</table>

<table style="width: 80%;">
  <colgroup>
    <col style="width: 35%;"/>
    <col style="width: 35%;"/>
    <col style="width: 30%;"/>
  </colgroup>
  <tr>
    <td rowspan="3" style="font-size: 350%" id="letters-display-big-letters"></td>
    <th style="text-align: right">Sounds like&#8230;</th>
    <td id="letters-display-sounds-like"></td>
  </tr>
  <tr>
    <th style="text-align: right">IPA</th>
    <td id="letters-display-ipa"></td>
  </tr>
  <tr>
    <th style="text-align: right">Input</th>
    <td><code>&ldquo;<span id="letters-display-input"></span>&rdquo;</code></td>
  </tr>
</table>

<textarea id="input"
  placeholder="Trai taipiń hiy&#8230;"
  oninput="addDiacritics()"
  onkeypress="addDiacritics()"
  rows="5">
</textarea>

<p>Some example sentences:</p>

<ul>
  <li>Ðy cłic brawn focs ǵumpt ywvy ðy leizí dog.</li>
  <li>Iuventius, if ai łý ólłeiz ylawd / ty cis jó huní-słít aiz&#8230;</li>
  <li>Ðen felt ai laic sum łoćy ov ðy scaiz / Łen y njẃ planit słimz intẃ hiz cen;</li>
</ul>

<script>
const LETTERS = "{%- for letter_data in site.data.spelling.letters -%}{{ letter_data[0] }}{%- endfor -%}";
const DISPLAY_DATA = {
    "letters": {{ site.data.spelling.letters | jsonify }},
    "diphthongs": {{ site.data.spelling.diphthongs | jsonify }}
};

/* Converts letter/diphthong data of the form in `_data/spelling.json` into
a sequence of display letters, sounds-like string, IPA string, and optionally input type.
*/
const letter_data_to_info = (letter, letter_data, table_type) => {
    const display_letter = letter.length == 1
        ? `${letter.toUpperCase()}${letter}`
        : `${letter}`;
    const sounds_like = letter_data["pronunciations"]
        .map(data => {
            var word = data["example"];
            var start = data["example_start"];
            var end = data["example_end"];
            return `${word.slice(0,start)}<strong>${word.slice(start,end)}</strong>${word.slice(end)}`;
        }).join(", ");
    const ipa = letter_data["pronunciations"].map(data => `/${data["ipa"]}/`).join(", ");
    return {
        "display_letter": display_letter,
        "sounds_like":  sounds_like,
        "ipa": ipa,
        "input": [...letter]
        .map(l => {
            const data = DISPLAY_DATA["letters"][l];
            var mod = data["modification_of"];
            return mod === undefined || mod === null ? l : `${mod}{{ site.data.spelling.accent_key }}`;
        }).join(""),
    };
}

const update_letter_display = (str) => {
    const table_type = str.length == 1 ? "letters" : "diphthongs";
    const data = DISPLAY_DATA[table_type][str];
    const letter_info = letter_data_to_info(str, data,
        table_type);
    document.getElementById(`letters-display-big-letters`)
        .innerText = letter_info["display_letter"];
    document.getElementById(`letters-display-sounds-like`)
        .innerHTML = letter_info["sounds_like"];
    document.getElementById(`letters-display-ipa`)
        .innerText = letter_info["ipa"];
    document.getElementById(`letters-display-input`)
        .innerText = letter_info["input"];
}

update_letter_display("{%- assign firstLetterInfo = site.data.spelling.letters | first -%}{{ firstLetterInfo[0] }}", "letters");
</script>



<div style="height: 20em"></div>
<h2>The details</h2>

<!-- TODO: generate these and preferably hide them under a dropdown. -->

(v0.3.0)

<p>Each phoneme of British Received Pronunciation English (the standard used in British dictionaries) maps to a single letter.</p>

<ul>
<li>Existing spelling conventions such as capitalised &ldquo;I&rdquo; and use of apostrophes are removed, but capitalisation and use of other punctuation remains unchanged, with the exception of guillemets for quotations as in French (&laquo; and &raquo;, or &lsaquo; and &rsaquo; for nested quotations).</li>
<!-- <li>The sounds /tr/ and /dr/ as in &ldquo;<strong>tr</strong>ip&rdquo; and &ldquo;<strong>dr</strong>ag&rdquo; are written as &laquo;ćr&raquo; and &laquo;ǵr&raquo; respectively. NB: not at all wedded to this.</li> -->
<li>An apostrophe is used between adjacent vowels which could form a diphthong, but do not. For example, &ldquo;clawing&rdquo; is written &laquo;cló&#8217;iń&raquo;.</li>
<li>English has five triphthongs, all of which are a diphthong + /ə/; no apostrophe is used between the constituent vowels.</li>
<li>Syllabic consonants like the final syllables of mansion, chasm and handle are written with a <strong>y</strong> before the consonant: &laquo;manśyn&raquo;, &laquo;cazym&raquo;, &laquo;handyl&raquo;.</li>
<li>The word &ldquo;the&rdquo; is written &laquo;ðy&raquo; before consonants and &laquo;ðí&raquo; before vowels, reflecting the pronunciation like &ldquo;a&rdquo; and &ldquo;an&rdquo;.</li>
<li>Reduced vowels are something I&#8217;m going to think more about.</li>
</ul>
<h2>Examples</h2>

<p>This section is unfinished.</p>

<blockquote>
<h3>The North Wind and the Sun</h3>
<p>The North Wind and the Sun were disputing which was the stronger, when a traveler came along wrapped in a warm cloak. They agreed that the one who first succeeded in making the traveler take his cloak off should be considered stronger than the other. Then the North Wind blew as hard as he could, but the more he blew the more closely did the traveler fold his cloak around him; and at last the North Wind gave up the attempt. Then the Sun shined out warmly, and immediately the traveler took off his cloak. And so the North Wind was obliged to confess that the Sun was the stronger of the two.</p>
</blockquote>
<blockquote>
<h3>Ðy Nóþ Łind and ðy Sun</h3>
<p>Ðy Nóþ Łind and ðy Sun łý dispjẃtiń łić łoz ðy strońgy, łen y travyly ceim yloń rapt in y łóm clywk. Ðei ygríd ðat ðy łun hẃ fýst sucsídyd in meicing ðy travyly teic hiz clywk of śud bí cynsidyd strońgy ðan ðí uðy. Ðen ðy Nóþ Łind blẃ az hád az hí cwd, but ðy mó hí blẃ ðy mó clywslí did ðy travyly fywld hiz clywc yrawnd him; and at lást ðy Nóþ Łind geiv up ðí ytempt. Ðen ðy Sun śaind awt łómlí, and imídíytly ðy travyly twc of hiz clywc. And syw ðy Nóþ Łind łoz yblaiǵd tẃ cynfes ðat ðy Sun łoz ðy strońgy ov ðy tẃ.</p>
</blockquote>
